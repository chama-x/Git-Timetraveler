use crate::git_context::{GitContext, GitIdentity};
use crate::session::{SessionManager, SessionSuggestions};
use anyhow::Result;
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;
use std::time::Instant;

/// Intelligent defaults engine that analyzes context and provides smart suggestions
pub struct DefaultsEngine {
    session_manager: SessionManager,
}

/// Comprehensive defaults generated by the engine
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IntelligentDefaults {
    /// Suggested repository name
    pub repository: Option<String>,
    /// Suggested branch name
    pub branch: String,
    /// Suggested author mode
    pub author_mode: AuthorMode,
    /// Suggested year(s) for time travel
    pub suggested_years: Vec<u32>,
    /// Suggested time of day (hour)
    pub suggested_hour: u32,
    /// Suggested GitHub username
    pub github_username: Option<String>,
    /// Confidence level (0.0 to 1.0)
    pub confidence: f32,
    /// Reasoning for the suggestions
    pub reasoning: Vec<String>,
    /// Generation time in milliseconds
    pub generation_time_ms: u64,
}

/// Author mode options
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AuthorMode {
    /// Use current Git user identity
    CurrentUser(GitIdentity),
    /// Use generic time traveler identity
    TimeTraveler,
    /// Ask user each time
    AskEachTime,
}

/// Context analysis result
#[derive(Debug, Clone)]
pub struct ContextAnalysis {
    /// Git repository context
    pub git_context: GitContext,
    /// Current working directory
    pub working_directory: String,
    /// Session-based suggestions
    pub session_suggestions: SessionSuggestions,
    /// Detected patterns
    pub patterns: Vec<DetectedPattern>,
}

/// Detected usage patterns with enhanced pattern matching
#[derive(Debug, Clone)]
pub enum DetectedPattern {
    /// User frequently works in this directory
    FrequentDirectory { path: String, usage_count: u32 },
    /// User prefers specific years with pattern analysis
    PreferredYears { years: Vec<u32>, confidence: f32, pattern_type: YearPatternType },
    /// User has consistent author preference
    ConsistentAuthor { mode: AuthorMode, confidence: f32 },
    /// User works with specific repositories
    PreferredRepositories { repos: Vec<String>, confidence: f32 },
    /// User has time preferences with pattern analysis
    TimePattern { hour: u32, confidence: f32, consistency: f32 },
    /// User prefers specific branch naming patterns
    BranchPattern { pattern: BranchPatternType, confidence: f32 },
    /// User has consistent working directory patterns
    WorkflowPattern { pattern: WorkflowPatternType, confidence: f32 },
    /// User has GitHub integration patterns
    GitHubPattern { pattern: GitHubPatternType, confidence: f32 },
}

/// Types of year selection patterns
#[derive(Debug, Clone, PartialEq)]
pub enum YearPatternType {
    /// User prefers specific decades (e.g., 1990s)
    DecadePreference(u32),
    /// User prefers sequential years
    Sequential,
    /// User prefers milestone years (e.g., 1990, 2000, 2010)
    Milestones,
    /// User has random/varied preferences
    Varied,
}

/// Types of branch naming patterns
#[derive(Debug, Clone, PartialEq)]
pub enum BranchPatternType {
    /// Always uses main/master
    MainBranch,
    /// Uses feature branch naming
    FeatureBranches,
    /// Uses custom naming convention
    CustomNaming(String),
}

/// Types of workflow patterns
#[derive(Debug, Clone, PartialEq)]
pub enum WorkflowPatternType {
    /// Always commits staged files
    StagedFilesWorkflow,
    /// Always creates new content
    NewContentWorkflow,
    /// Mixed workflow
    MixedWorkflow,
}

/// Types of GitHub integration patterns
#[derive(Debug, Clone, PartialEq)]
pub enum GitHubPatternType {
    /// Consistent repository naming
    ConsistentNaming(String),
    /// Uses organization repositories
    OrganizationRepos,
    /// Personal repositories only
    PersonalRepos,
}

/// Intelligent suggestions based on pattern analysis
#[derive(Debug, Clone)]
pub struct IntelligentSuggestion {
    pub suggestion_type: SuggestionType,
    pub confidence: f32,
    pub reasoning: String,
}

/// Types of intelligent suggestions
#[derive(Debug, Clone)]
pub enum SuggestionType {
    /// Suggest next year in sequence
    NextYear(u32),
    /// Suggest repository naming pattern
    RepositoryNaming(String),
    /// Suggest branch name
    BranchName(String),
    /// Suggest author mode
    AuthorMode(AuthorMode),
    /// Suggest time of day
    TimeOfDay(u32),
}

impl DefaultsEngine {
    /// Create a new defaults engine
    pub fn new() -> Result<Self> {
        let session_manager = SessionManager::new()?;
        Ok(Self { session_manager })
    }

    /// Generate intelligent defaults based on current context
    pub fn generate_defaults(&mut self, current_path: Option<&Path>) -> Result<IntelligentDefaults> {
        let start_time = Instant::now();
        let current_path = current_path.unwrap_or_else(|| Path::new("."));
        
        // Analyze current context
        let analysis = self.analyze_context(current_path)?;
        
        // Generate defaults using pattern matching
        let defaults = self.generate_from_analysis(&analysis)?;
        
        let generation_time = start_time.elapsed().as_millis() as u64;
        
        Ok(IntelligentDefaults {
            generation_time_ms: generation_time,
            ..defaults
        })
    }

    /// Analyze current context comprehensively
    fn analyze_context(&mut self, current_path: &Path) -> Result<ContextAnalysis> {
        // Get Git context
        let mut git_detector = crate::git_context::GitContextDetector::new();
        let git_context = git_detector.detect_context(Some(current_path))?;
        
        // Get session suggestions
        let session_suggestions = self.session_manager.get_suggestions(current_path);
        
        // Detect patterns
        let patterns = self.detect_patterns(&git_context, &session_suggestions);
        
        Ok(ContextAnalysis {
            git_context,
            working_directory: current_path.display().to_string(),
            session_suggestions,
            patterns,
        })
    }

    /// Generate defaults from context analysis using pattern matching
    fn generate_from_analysis(&self, analysis: &ContextAnalysis) -> Result<IntelligentDefaults> {
        let mut defaults = IntelligentDefaults {
            repository: None,
            branch: "main".to_string(),
            author_mode: AuthorMode::TimeTraveler,
            suggested_years: vec![1990],
            suggested_hour: 18,
            github_username: None,
            confidence: 0.5,
            reasoning: Vec::new(),
            generation_time_ms: 0,
        };

        let mut confidence_factors = Vec::new();
        
        // Pattern match on Git context
        match &analysis.git_context {
            git_ctx if git_ctx.is_git_repo => {
                self.apply_git_repo_patterns(git_ctx, &mut defaults, &mut confidence_factors);
            }
            _ => {
                defaults.reasoning.push("No Git repository detected - using general defaults".to_string());
                confidence_factors.push(0.3);
            }
        }

        // Pattern match on session suggestions
        self.apply_session_patterns(&analysis.session_suggestions, &mut defaults, &mut confidence_factors);

        // Pattern match on detected patterns
        for pattern in &analysis.patterns {
            self.apply_detected_pattern(pattern, &mut defaults, &mut confidence_factors);
        }

        // Calculate overall confidence
        defaults.confidence = if confidence_factors.is_empty() {
            0.3
        } else {
            confidence_factors.iter().sum::<f32>() / confidence_factors.len() as f32
        };

        Ok(defaults)
    }

    /// Apply Git repository context patterns
    fn apply_git_repo_patterns(&self, git_ctx: &GitContext, defaults: &mut IntelligentDefaults, 
                              confidence_factors: &mut Vec<f32>) {
        // Repository name inference
        if let Some(github_remote) = git_ctx.get_github_remote() {
            if let Some(repo_name) = self.extract_repo_name_from_url(&github_remote.url) {
                defaults.repository = Some(repo_name);
                defaults.reasoning.push("Inferred repository from GitHub remote".to_string());
                confidence_factors.push(0.9);
            }
        }

        // Branch selection
        match &git_ctx.current_branch {
            Some(branch) => {
                defaults.branch = branch.clone();
                defaults.reasoning.push(format!("Using current branch: {}", branch));
                confidence_factors.push(0.8);
            }
            None => {
                // Choose best available branch
                if git_ctx.available_branches.contains(&"main".to_string()) {
                    defaults.branch = "main".to_string();
                } else if git_ctx.available_branches.contains(&"master".to_string()) {
                    defaults.branch = "master".to_string();
                } else if let Some(first_branch) = git_ctx.available_branches.first() {
                    defaults.branch = first_branch.clone();
                }
                defaults.reasoning.push("Selected best available branch".to_string());
                confidence_factors.push(0.6);
            }
        }

        // Author mode selection
        match &git_ctx.user_identity {
            Some(identity) => {
                defaults.author_mode = AuthorMode::CurrentUser(identity.clone());
                defaults.reasoning.push(format!("Using Git identity: {}", identity.name));
                confidence_factors.push(0.9);
            }
            None => {
                defaults.author_mode = AuthorMode::TimeTraveler;
                defaults.reasoning.push("No Git identity found - using time traveler mode".to_string());
                confidence_factors.push(0.4);
            }
        }

        // GitHub username extraction
        if let Some(_identity) = &git_ctx.user_identity {
            if let Some(github_remote) = git_ctx.get_github_remote() {
                if let Some(username) = self.extract_username_from_url(&github_remote.url) {
                    defaults.github_username = Some(username);
                    defaults.reasoning.push("Extracted GitHub username from remote".to_string());
                    confidence_factors.push(0.8);
                }
            }
        }
    }

    /// Apply session-based patterns
    fn apply_session_patterns(&self, suggestions: &SessionSuggestions, defaults: &mut IntelligentDefaults,
                             confidence_factors: &mut Vec<f32>) {
        // Repository suggestions
        if let Some(ref repo) = suggestions.suggested_repository {
            if defaults.repository.is_none() {
                defaults.repository = Some(repo.clone());
                defaults.reasoning.push("Using repository from session history".to_string());
                confidence_factors.push(0.7);
            }
        }

        // Branch suggestions
        if let Some(ref branch) = suggestions.suggested_branch {
            defaults.branch = branch.clone();
            defaults.reasoning.push("Using branch from session history".to_string());
            confidence_factors.push(0.7);
        }

        // Author mode suggestions
        if let Some(ref author_mode) = suggestions.suggested_author_mode {
            match author_mode.as_str() {
                "current_user" => {
                    // Keep current user mode if already set
                    if matches!(defaults.author_mode, AuthorMode::CurrentUser(_)) {
                        defaults.reasoning.push("Confirmed current user mode from session".to_string());
                        confidence_factors.push(0.8);
                    }
                }
                "time_traveler" => {
                    defaults.author_mode = AuthorMode::TimeTraveler;
                    defaults.reasoning.push("Using time traveler mode from session".to_string());
                    confidence_factors.push(0.8);
                }
                _ => {}
            }
        }

        // Year suggestions
        if !suggestions.suggested_years.is_empty() {
            defaults.suggested_years = suggestions.suggested_years.clone();
            defaults.reasoning.push("Using years from session history".to_string());
            confidence_factors.push(0.8);
        }

        // Hour suggestions
        if let Some(hour) = suggestions.suggested_hour {
            defaults.suggested_hour = hour;
            defaults.reasoning.push(format!("Using preferred time: {}:00", hour));
            confidence_factors.push(0.7);
        }

        // GitHub username
        if let Some(ref username) = suggestions.github_username {
            if defaults.github_username.is_none() {
                defaults.github_username = Some(username.clone());
                defaults.reasoning.push("Using GitHub username from session".to_string());
                confidence_factors.push(0.8);
            }
        }
    }

    /// Apply detected patterns using enhanced pattern matching
    fn apply_detected_pattern(&self, pattern: &DetectedPattern, defaults: &mut IntelligentDefaults,
                             confidence_factors: &mut Vec<f32>) {
        match pattern {
            DetectedPattern::PreferredYears { years, confidence, pattern_type } => {
                if !years.is_empty() {
                    defaults.suggested_years = years.clone();
                    let reasoning = match pattern_type {
                        YearPatternType::DecadePreference(decade) => {
                            format!("Using {}s decade preference", decade)
                        }
                        YearPatternType::Sequential => {
                            "Using sequential year pattern".to_string()
                        }
                        YearPatternType::Milestones => {
                            "Using milestone year pattern".to_string()
                        }
                        YearPatternType::Varied => {
                            "Using varied year preferences".to_string()
                        }
                    };
                    defaults.reasoning.push(reasoning);
                    confidence_factors.push(*confidence);
                }
            }
            DetectedPattern::ConsistentAuthor { mode, confidence } => {
                defaults.author_mode = mode.clone();
                defaults.reasoning.push("Using consistent author preference".to_string());
                confidence_factors.push(*confidence);
            }
            DetectedPattern::PreferredRepositories { repos, confidence } => {
                if let Some(first_repo) = repos.first() {
                    if defaults.repository.is_none() {
                        defaults.repository = Some(first_repo.clone());
                        defaults.reasoning.push("Using frequently used repository".to_string());
                        confidence_factors.push(*confidence);
                    }
                }
            }
            DetectedPattern::TimePattern { hour, confidence, consistency } => {
                defaults.suggested_hour = *hour;
                let reasoning = if *consistency > 0.8 {
                    format!("Using highly consistent time pattern: {}:00", hour)
                } else {
                    format!("Using preferred time pattern: {}:00", hour)
                };
                defaults.reasoning.push(reasoning);
                confidence_factors.push(*confidence);
            }
            DetectedPattern::BranchPattern { pattern, confidence } => {
                match pattern {
                    BranchPatternType::MainBranch => {
                        if defaults.branch == "main" || defaults.branch == "master" {
                            defaults.reasoning.push("Confirmed main branch preference".to_string());
                            confidence_factors.push(*confidence);
                        }
                    }
                    BranchPatternType::FeatureBranches => {
                        defaults.reasoning.push("Detected feature branch workflow".to_string());
                        confidence_factors.push(*confidence * 0.8); // Slightly lower confidence for feature branches
                    }
                    BranchPatternType::CustomNaming(name) => {
                        defaults.branch = name.clone();
                        defaults.reasoning.push("Using custom branch naming pattern".to_string());
                        confidence_factors.push(*confidence);
                    }
                }
            }
            DetectedPattern::WorkflowPattern { pattern, confidence } => {
                match pattern {
                    WorkflowPatternType::StagedFilesWorkflow => {
                        defaults.reasoning.push("Detected staged files workflow preference".to_string());
                    }
                    WorkflowPatternType::NewContentWorkflow => {
                        defaults.reasoning.push("Detected new content creation workflow".to_string());
                    }
                    WorkflowPatternType::MixedWorkflow => {
                        defaults.reasoning.push("Detected mixed workflow pattern".to_string());
                    }
                }
                confidence_factors.push(*confidence);
            }
            DetectedPattern::GitHubPattern { pattern, confidence } => {
                match pattern {
                    GitHubPatternType::ConsistentNaming(prefix) => {
                        defaults.reasoning.push(format!("Detected consistent repository naming: {}", prefix));
                    }
                    GitHubPatternType::OrganizationRepos => {
                        defaults.reasoning.push("Detected organization repository pattern".to_string());
                    }
                    GitHubPatternType::PersonalRepos => {
                        defaults.reasoning.push("Detected personal repository pattern".to_string());
                    }
                }
                confidence_factors.push(*confidence);
            }
            DetectedPattern::FrequentDirectory { .. } => {
                // This pattern affects confidence but not specific defaults
                confidence_factors.push(0.1);
            }
        }
    }

    /// Detect usage patterns from context using advanced pattern matching
    fn detect_patterns(&self, git_context: &GitContext, suggestions: &SessionSuggestions) -> Vec<DetectedPattern> {
        let mut patterns = Vec::new();

        // Detect preferred years pattern with advanced analysis
        if !suggestions.suggested_years.is_empty() {
            let (confidence, pattern_type) = self.analyze_year_patterns(&suggestions.suggested_years);
            patterns.push(DetectedPattern::PreferredYears {
                years: suggestions.suggested_years.clone(),
                confidence,
                pattern_type,
            });
        }

        // Detect consistent author pattern
        if let Some(ref author_mode) = suggestions.suggested_author_mode {
            let confidence = 0.7;
            let mode = match author_mode.as_str() {
                "current_user" => {
                    if let Some(ref identity) = git_context.user_identity {
                        AuthorMode::CurrentUser(identity.clone())
                    } else {
                        AuthorMode::AskEachTime
                    }
                }
                "time_traveler" => AuthorMode::TimeTraveler,
                _ => AuthorMode::AskEachTime,
            };
            patterns.push(DetectedPattern::ConsistentAuthor { mode, confidence });
        }

        // Detect preferred repositories pattern
        if !suggestions.suggested_repositories.is_empty() {
            let confidence = if suggestions.suggested_repositories.len() >= 2 { 0.7 } else { 0.5 };
            patterns.push(DetectedPattern::PreferredRepositories {
                repos: suggestions.suggested_repositories.clone(),
                confidence,
            });
        }

        // Detect time pattern with consistency analysis
        if let Some(hour) = suggestions.suggested_hour {
            let consistency = self.calculate_time_consistency(hour, suggestions);
            patterns.push(DetectedPattern::TimePattern {
                hour,
                confidence: 0.6 + (consistency * 0.3), // Boost confidence based on consistency
                consistency,
            });
        }

        // Detect branch patterns
        if let Some(branch_pattern) = self.detect_branch_pattern(git_context, suggestions) {
            patterns.push(branch_pattern);
        }

        // Detect workflow patterns
        if let Some(workflow_pattern) = self.detect_workflow_pattern(git_context) {
            patterns.push(workflow_pattern);
        }

        // Detect GitHub patterns
        if let Some(github_pattern) = self.detect_github_pattern(git_context, suggestions) {
            patterns.push(github_pattern);
        }

        patterns
    }

    /// Analyze year selection patterns using Rust pattern matching
    fn analyze_year_patterns(&self, years: &[u32]) -> (f32, YearPatternType) {
        if years.len() < 2 {
            return (0.5, YearPatternType::Varied);
        }

        let mut sorted_years = years.to_vec();
        sorted_years.sort();

        // Check for sequential pattern first (highest priority)
        let is_consecutive = sorted_years.windows(2)
            .all(|window| window[1] - window[0] == 1);
        
        if is_consecutive && years.len() >= 3 {
            return (0.9, YearPatternType::Sequential);
        }

        // Check for nearly sequential (gaps of 2 years max)
        let is_nearly_sequential = sorted_years.windows(2)
            .all(|window| window[1] - window[0] <= 2);
        
        if is_nearly_sequential && years.len() >= 4 {
            return (0.85, YearPatternType::Sequential);
        }

        // Check for decade preference
        let decades: HashMap<u32, u32> = sorted_years.iter()
            .fold(HashMap::new(), |mut acc, &year| {
                let decade = (year / 10) * 10;
                *acc.entry(decade).or_insert(0) += 1;
                acc
            });

        if let Some((&preferred_decade, &count)) = decades.iter().max_by_key(|(_, &count)| count) {
            if count as f32 / years.len() as f32 > 0.6 {
                return (0.8, YearPatternType::DecadePreference(preferred_decade));
            }
        }

        // Check for milestone years (ending in 0 or 5)
        let milestone_count = years.iter()
            .filter(|&&year| year % 10 == 0 || year % 10 == 5)
            .count();
        
        if milestone_count as f32 / years.len() as f32 > 0.7 {
            return (0.7, YearPatternType::Milestones);
        }

        (0.6, YearPatternType::Varied)
    }

    /// Calculate time consistency for pattern analysis
    fn calculate_time_consistency(&self, _hour: u32, _suggestions: &SessionSuggestions) -> f32 {
        // In a real implementation, this would analyze historical time choices
        // For now, return a reasonable default
        0.7
    }

    /// Detect branch naming patterns
    fn detect_branch_pattern(&self, git_context: &GitContext, _suggestions: &SessionSuggestions) -> Option<DetectedPattern> {
        match &git_context.current_branch {
            Some(branch) => {
                let pattern_type = match branch.as_str() {
                    "main" | "master" => BranchPatternType::MainBranch,
                    branch_name if branch_name.starts_with("feature/") || 
                                   branch_name.starts_with("feat/") ||
                                   branch_name.contains("feature") => BranchPatternType::FeatureBranches,
                    custom => BranchPatternType::CustomNaming(custom.to_string()),
                };

                Some(DetectedPattern::BranchPattern {
                    pattern: pattern_type,
                    confidence: 0.6,
                })
            }
            None => None,
        }
    }

    /// Detect workflow patterns based on Git context
    fn detect_workflow_pattern(&self, git_context: &GitContext) -> Option<DetectedPattern> {
        let pattern_type = match (git_context.has_staged_files(), git_context.has_modified_files()) {
            (true, _) => WorkflowPatternType::StagedFilesWorkflow,
            (false, true) => WorkflowPatternType::NewContentWorkflow,
            (false, false) => WorkflowPatternType::MixedWorkflow,
        };

        Some(DetectedPattern::WorkflowPattern {
            pattern: pattern_type,
            confidence: 0.5,
        })
    }

    /// Detect GitHub integration patterns
    fn detect_github_pattern(&self, git_context: &GitContext, suggestions: &SessionSuggestions) -> Option<DetectedPattern> {
        if let Some(github_remote) = git_context.get_github_remote() {
            // Analyze repository naming patterns
            let repos = &suggestions.suggested_repositories;
            if repos.len() >= 2 {
                // Check for consistent naming patterns
                let has_consistent_prefix = repos.iter()
                    .all(|repo| repo.starts_with(&repos[0][..2.min(repos[0].len())]));
                
                if has_consistent_prefix {
                    return Some(DetectedPattern::GitHubPattern {
                        pattern: GitHubPatternType::ConsistentNaming(repos[0][..2.min(repos[0].len())].to_string()),
                        confidence: 0.7,
                    });
                }
            }

            // Check if it's an organization repo
            if let Some(username) = self.extract_username_from_url(&github_remote.url) {
                if suggestions.github_username.as_ref().map_or(false, |u| u != &username) {
                    return Some(DetectedPattern::GitHubPattern {
                        pattern: GitHubPatternType::OrganizationRepos,
                        confidence: 0.8,
                    });
                }
            }

            Some(DetectedPattern::GitHubPattern {
                pattern: GitHubPatternType::PersonalRepos,
                confidence: 0.6,
            })
        } else {
            None
        }
    }

    /// Extract repository name from GitHub URL using optimized regex
    fn extract_repo_name_from_url(&self, url: &str) -> Option<String> {
        // Use lazy static regex for better performance
        lazy_static::lazy_static! {
            static ref REPO_REGEX: Regex = Regex::new(r"github\.com[:/]([^/]+)/([^/]+)").unwrap();
        }
        
        let url = url.trim_end_matches(".git");
        REPO_REGEX.captures(url)
            .and_then(|captures| captures.get(2))
            .map(|m| m.as_str().to_string())
    }

    /// Extract username from GitHub URL using optimized regex
    fn extract_username_from_url(&self, url: &str) -> Option<String> {
        lazy_static::lazy_static! {
            static ref USER_REGEX: Regex = Regex::new(r"github\.com[:/]([^/]+)/").unwrap();
        }
        
        USER_REGEX.captures(url)
            .and_then(|captures| captures.get(1))
            .map(|m| m.as_str().to_string())
    }

    /// Optimize defaults generation for speed
    pub fn generate_fast_defaults(&mut self, current_path: Option<&Path>) -> Result<IntelligentDefaults> {
        // Use cached analysis if available and recent
        let start_time = Instant::now();
        let current_path = current_path.unwrap_or_else(|| Path::new("."));
        
        // Quick analysis focusing on most important patterns
        let mut git_detector = crate::git_context::GitContextDetector::new();
        let git_context = git_detector.detect_context(Some(current_path))?;
        let session_suggestions = self.session_manager.get_suggestions(current_path);
        
        // Generate defaults with minimal pattern analysis for speed
        let mut defaults = IntelligentDefaults {
            repository: None,
            branch: "main".to_string(),
            author_mode: AuthorMode::TimeTraveler,
            suggested_years: vec![1990],
            suggested_hour: 18,
            github_username: None,
            confidence: 0.5,
            reasoning: vec!["Fast generation mode".to_string()],
            generation_time_ms: 0,
        };

        // Apply only the most confident patterns for speed
        if let Some(ref repo) = session_suggestions.suggested_repository {
            defaults.repository = Some(repo.clone());
            defaults.confidence += 0.2;
        }

        if !session_suggestions.suggested_years.is_empty() {
            defaults.suggested_years = session_suggestions.suggested_years.clone();
            defaults.confidence += 0.2;
        }

        if let Some(ref identity) = git_context.user_identity {
            defaults.author_mode = AuthorMode::CurrentUser(identity.clone());
            defaults.confidence += 0.2;
        }

        defaults.generation_time_ms = start_time.elapsed().as_millis() as u64;
        Ok(defaults)
    }

    /// Get intelligent suggestions based on detected patterns
    pub fn get_intelligent_suggestions(&mut self, current_path: Option<&Path>) -> Result<Vec<IntelligentSuggestion>> {
        let analysis = self.analyze_context(current_path.unwrap_or_else(|| Path::new(".")))?;
        let mut suggestions = Vec::new();

        for pattern in &analysis.patterns {
            match pattern {
                DetectedPattern::PreferredYears { years, confidence, pattern_type } => {
                    if *confidence > 0.7 {
                        match pattern_type {
                            YearPatternType::Sequential => {
                                if let Some(&last_year) = years.last() {
                                    suggestions.push(IntelligentSuggestion {
                                        suggestion_type: SuggestionType::NextYear(last_year + 1),
                                        confidence: *confidence,
                                        reasoning: "Continue sequential year pattern".to_string(),
                                    });
                                }
                            }
                            YearPatternType::DecadePreference(decade) => {
                                let next_in_decade = decade + (years.len() as u32);
                                if next_in_decade < decade + 10 {
                                    suggestions.push(IntelligentSuggestion {
                                        suggestion_type: SuggestionType::NextYear(next_in_decade),
                                        confidence: *confidence,
                                        reasoning: format!("Continue {}s decade pattern", decade),
                                    });
                                }
                            }
                            _ => {}
                        }
                    }
                }
                DetectedPattern::GitHubPattern { pattern, confidence } => {
                    if *confidence > 0.6 {
                        match pattern {
                            GitHubPatternType::ConsistentNaming(prefix) => {
                                suggestions.push(IntelligentSuggestion {
                                    suggestion_type: SuggestionType::RepositoryNaming(prefix.clone()),
                                    confidence: *confidence,
                                    reasoning: "Use consistent repository naming".to_string(),
                                });
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
        }

        Ok(suggestions)
    }

    /// Learn from user choices to improve future defaults
    pub fn learn_from_choice(&mut self, choice_type: &str, value: &str) -> Result<()> {
        self.session_manager.learn_from_choice(choice_type, value);
        self.session_manager.save()?;
        Ok(())
    }

    /// Update context information
    pub fn update_context(&mut self, working_dir: &Path, repo_name: Option<&str>, 
                         branch_name: Option<&str>, user_identity: Option<&str>, 
                         success: bool) -> Result<()> {
        self.session_manager.update_context(working_dir, repo_name, branch_name, user_identity, success);
        self.session_manager.save()?;
        Ok(())
    }
}

impl IntelligentDefaults {
    /// Get a human-readable summary of the defaults
    pub fn summary(&self) -> String {
        let mut parts = Vec::new();
        
        if let Some(ref repo) = self.repository {
            parts.push(format!("Repository: {}", repo));
        }
        
        parts.push(format!("Branch: {}", self.branch));
        
        match &self.author_mode {
            AuthorMode::CurrentUser(identity) => {
                parts.push(format!("Author: {} <{}>", identity.name, identity.email));
            }
            AuthorMode::TimeTraveler => {
                parts.push("Author: Time Traveler".to_string());
            }
            AuthorMode::AskEachTime => {
                parts.push("Author: (will ask)".to_string());
            }
        }
        
        if !self.suggested_years.is_empty() {
            if self.suggested_years.len() == 1 {
                parts.push(format!("Year: {}", self.suggested_years[0]));
            } else {
                parts.push(format!("Years: {:?}", self.suggested_years));
            }
        }
        
        parts.push(format!("Time: {:02}:00", self.suggested_hour));
        parts.push(format!("Confidence: {:.0}%", self.confidence * 100.0));
        
        parts.join(" | ")
    }

    /// Check if defaults have high confidence
    pub fn is_high_confidence(&self) -> bool {
        self.confidence >= 0.7
    }

    /// Get the primary suggested year
    pub fn primary_year(&self) -> u32 {
        self.suggested_years.first().copied().unwrap_or(1990)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;


    fn create_test_git_context() -> GitContext {
        let mut context = GitContext::default();
        context.is_git_repo = true;
        context.current_branch = Some("main".to_string());
        context.user_identity = Some(GitIdentity {
            name: "Test User".to_string(),
            email: "test@example.com".to_string(),
        });
        context
    }

    #[test]
    fn test_defaults_generation() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let mut engine = DefaultsEngine::new()?;
        
        let defaults = engine.generate_defaults(Some(temp_dir.path()))?;
        
        assert!(!defaults.branch.is_empty());
        assert!(defaults.suggested_hour <= 23);
        assert!(!defaults.suggested_years.is_empty());
        assert!(defaults.confidence >= 0.0 && defaults.confidence <= 1.0);
        assert!(!defaults.reasoning.is_empty());
        
        Ok(())
    }

    #[test]
    fn test_git_repo_patterns() -> Result<()> {
        let temp_dir = TempDir::new()?;
        
        // Create a git repository
        let repo = git2::Repository::init(temp_dir.path())?;
        let mut config = repo.config()?;
        config.set_str("user.name", "Test User")?;
        config.set_str("user.email", "test@example.com")?;
        
        // Add a GitHub remote
        repo.remote("origin", "https://github.com/testuser/testrepo.git")?;
        
        let mut engine = DefaultsEngine::new()?;
        let defaults = engine.generate_defaults(Some(temp_dir.path()))?;
        
        assert_eq!(defaults.repository, Some("testrepo".to_string()));
        assert!(matches!(defaults.author_mode, AuthorMode::CurrentUser(_)));
        assert!(defaults.confidence > 0.5);
        
        Ok(())
    }

    #[test]
    fn test_pattern_detection() -> Result<()> {
        let engine = DefaultsEngine::new()?;
        let git_context = create_test_git_context();
        
        let mut suggestions = SessionSuggestions::default();
        suggestions.suggested_years = vec![1990, 1995, 2000];
        suggestions.suggested_author_mode = Some("current_user".to_string());
        suggestions.suggested_hour = Some(14);
        
        let patterns = engine.detect_patterns(&git_context, &suggestions);
        
        assert!(!patterns.is_empty());
        
        // Check for preferred years pattern
        let has_years_pattern = patterns.iter().any(|p| {
            matches!(p, DetectedPattern::PreferredYears { .. })
        });
        assert!(has_years_pattern);
        
        // Check for time pattern
        let has_time_pattern = patterns.iter().any(|p| {
            matches!(p, DetectedPattern::TimePattern { hour: 14, .. })
        });
        assert!(has_time_pattern);
        
        Ok(())
    }

    #[test]
    fn test_year_pattern_analysis() -> Result<()> {
        let engine = DefaultsEngine::new()?;
        
        // Test sequential pattern
        let sequential_years = vec![1990, 1991, 1992, 1993];
        let (confidence, pattern_type) = engine.analyze_year_patterns(&sequential_years);
        assert!(confidence >= 0.8); // Use >= instead of >
        assert_eq!(pattern_type, YearPatternType::Sequential);
        
        // Test decade preference
        let decade_years = vec![1990, 1991, 1995, 1996, 1999];
        let (confidence, pattern_type) = engine.analyze_year_patterns(&decade_years);
        assert!(confidence > 0.7);
        assert_eq!(pattern_type, YearPatternType::DecadePreference(1990));
        
        // Test milestone pattern
        let milestone_years = vec![1990, 1995, 2000, 2005];
        let (confidence, pattern_type) = engine.analyze_year_patterns(&milestone_years);
        assert!(confidence > 0.6);
        assert_eq!(pattern_type, YearPatternType::Milestones);
        
        Ok(())
    }

    #[test]
    fn test_branch_pattern_detection() -> Result<()> {
        let engine = DefaultsEngine::new()?;
        let mut git_context = create_test_git_context();
        let suggestions = SessionSuggestions::default();
        
        // Test main branch pattern
        git_context.current_branch = Some("main".to_string());
        let pattern = engine.detect_branch_pattern(&git_context, &suggestions);
        assert!(pattern.is_some());
        if let Some(DetectedPattern::BranchPattern { pattern, .. }) = pattern {
            assert_eq!(pattern, BranchPatternType::MainBranch);
        }
        
        // Test feature branch pattern
        git_context.current_branch = Some("feature/new-feature".to_string());
        let pattern = engine.detect_branch_pattern(&git_context, &suggestions);
        assert!(pattern.is_some());
        if let Some(DetectedPattern::BranchPattern { pattern, .. }) = pattern {
            assert_eq!(pattern, BranchPatternType::FeatureBranches);
        }
        
        Ok(())
    }

    #[test]
    fn test_intelligent_suggestions() -> Result<()> {
        let temp_dir = TempDir::new()?;
        
        // Create a test session manager in the temp directory
        let session_dir = temp_dir.path().join(".config").join("git-timetraveler");
        std::fs::create_dir_all(&session_dir)?;
        
        let session_file = session_dir.join("session.bin");
        let data = crate::session::SessionData::default();
        
        let session_manager = crate::session::SessionManager {
            session_dir,
            session_file,
            data,
        };
        
        let mut engine = DefaultsEngine {
            session_manager,
        };
        
        // Set up sequential year pattern
        engine.learn_from_choice("year", "1990")?;
        engine.learn_from_choice("year", "1991")?;
        engine.learn_from_choice("year", "1992")?;
        
        let suggestions = engine.get_intelligent_suggestions(Some(temp_dir.path()))?;
        
        // Should suggest next year in sequence
        let has_next_year = suggestions.iter().any(|s| {
            matches!(s.suggestion_type, SuggestionType::NextYear(1993))
        });
        assert!(has_next_year);
        
        Ok(())
    }

    #[test]
    fn test_fast_defaults_generation() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let mut engine = DefaultsEngine::new()?;
        
        let start_time = Instant::now();
        let defaults = engine.generate_fast_defaults(Some(temp_dir.path()))?;
        let generation_time = start_time.elapsed().as_millis();
        
        // Should be faster than regular generation
        assert!(generation_time < 50); // Target: under 50ms
        assert!(defaults.generation_time_ms < 50);
        assert!(!defaults.reasoning.is_empty());
        assert!(defaults.confidence >= 0.0 && defaults.confidence <= 1.0);
        
        Ok(())
    }

    #[test]
    fn test_url_extraction() -> Result<()> {
        let engine = DefaultsEngine::new()?;
        
        // Test repository name extraction
        assert_eq!(
            engine.extract_repo_name_from_url("https://github.com/user/repo.git"),
            Some("repo".to_string())
        );
        assert_eq!(
            engine.extract_repo_name_from_url("git@github.com:user/repo.git"),
            Some("repo".to_string())
        );
        
        // Test username extraction
        assert_eq!(
            engine.extract_username_from_url("https://github.com/testuser/repo.git"),
            Some("testuser".to_string())
        );
        
        Ok(())
    }

    #[test]
    fn test_defaults_summary() -> Result<()> {
        let defaults = IntelligentDefaults {
            repository: Some("test-repo".to_string()),
            branch: "main".to_string(),
            author_mode: AuthorMode::TimeTraveler,
            suggested_years: vec![1990],
            suggested_hour: 18,
            github_username: Some("testuser".to_string()),
            confidence: 0.85,
            reasoning: vec!["Test reasoning".to_string()],
            generation_time_ms: 5,
        };
        
        let summary = defaults.summary();
        assert!(summary.contains("Repository: test-repo"));
        assert!(summary.contains("Branch: main"));
        assert!(summary.contains("Author: Time Traveler"));
        assert!(summary.contains("Year: 1990"));
        assert!(summary.contains("Time: 18:00"));
        assert!(summary.contains("Confidence: 85%"));
        
        Ok(())
    }

    #[test]
    fn test_confidence_levels() -> Result<()> {
        let high_confidence = IntelligentDefaults {
            repository: None,
            branch: "main".to_string(),
            author_mode: AuthorMode::TimeTraveler,
            suggested_years: vec![1990],
            suggested_hour: 18,
            github_username: None,
            confidence: 0.8,
            reasoning: Vec::new(),
            generation_time_ms: 0,
        };
        
        let low_confidence = IntelligentDefaults {
            confidence: 0.4,
            ..high_confidence.clone()
        };
        
        assert!(high_confidence.is_high_confidence());
        assert!(!low_confidence.is_high_confidence());
        
        Ok(())
    }

    #[test]
    fn test_learning_integration() -> Result<()> {
        let mut engine = DefaultsEngine::new()?;
        
        // Learn some preferences
        engine.learn_from_choice("year", "1995")?;
        engine.learn_from_choice("repository", "my-project")?;
        engine.learn_from_choice("author_mode", "current_user")?;
        
        // Update context
        let temp_dir = TempDir::new()?;
        engine.update_context(
            temp_dir.path(),
            Some("my-project"),
            Some("main"),
            Some("testuser"),
            true
        )?;
        
        // Generate defaults should now reflect learned preferences
        let defaults = engine.generate_defaults(Some(temp_dir.path()))?;
        
        assert!(defaults.suggested_years.contains(&1995));
        // Note: repository might not be set if no git context is detected
        
        Ok(())
    }

    #[test]
    fn benchmark_defaults_generation_speed() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let mut engine = DefaultsEngine::new()?;
        
        // Warm up
        for _ in 0..5 {
            let _ = engine.generate_defaults(Some(temp_dir.path()))?;
        }
        
        // Benchmark multiple runs
        let mut times = Vec::new();
        for _ in 0..100 {
            let start = Instant::now();
            let _ = engine.generate_defaults(Some(temp_dir.path()))?;
            times.push(start.elapsed().as_millis());
        }
        
        let avg_time = times.iter().sum::<u128>() / times.len() as u128;
        let max_time = *times.iter().max().unwrap();
        
        println!("Average generation time: {}ms", avg_time);
        println!("Maximum generation time: {}ms", max_time);
        
        // Performance targets from requirements
        assert!(avg_time < 50, "Average time {}ms should be under 50ms", avg_time);
        assert!(max_time < 100, "Max time {}ms should be under 100ms", max_time);
        
        Ok(())
    }

    #[test]
    fn benchmark_pattern_analysis_speed() -> Result<()> {
        let engine = DefaultsEngine::new()?;
        
        // Test with various year patterns
        let test_cases = vec![
            vec![1990, 1991, 1992, 1993, 1994], // Sequential
            vec![1990, 1995, 2000, 2005, 2010], // Milestones
            vec![1990, 1991, 1995, 1996, 1999], // Decade preference
            vec![1980, 1990, 2000, 2010, 2020], // Varied
        ];
        
        for years in test_cases {
            let start = Instant::now();
            let _ = engine.analyze_year_patterns(&years);
            let time = start.elapsed().as_micros();
            
            // Pattern analysis should be very fast (under 2ms to account for system variance)
            assert!(time < 2000, "Pattern analysis took {}μs, should be under 2000μs", time);
        }
        
        Ok(())
    }

    #[test]
    fn benchmark_fast_defaults_vs_regular() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let mut engine = DefaultsEngine::new()?;
        
        // Benchmark regular defaults
        let start = Instant::now();
        let regular_defaults = engine.generate_defaults(Some(temp_dir.path()))?;
        let regular_time = start.elapsed().as_millis();
        
        // Benchmark fast defaults
        let start = Instant::now();
        let fast_defaults = engine.generate_fast_defaults(Some(temp_dir.path()))?;
        let fast_time = start.elapsed().as_millis();
        
        println!("Regular defaults: {}ms", regular_time);
        println!("Fast defaults: {}ms", fast_time);
        
        // Fast defaults should be faster
        assert!(fast_time <= regular_time, "Fast defaults ({}ms) should be <= regular ({}ms)", fast_time, regular_time);
        
        // Both should produce valid results
        assert!(regular_defaults.confidence >= 0.0 && regular_defaults.confidence <= 1.0);
        assert!(fast_defaults.confidence >= 0.0 && fast_defaults.confidence <= 1.0);
        
        Ok(())
    }
}