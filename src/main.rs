use anyhow::{Context, Result};
use chrono::DateTime;
use clap::Parser;
use colored::*;
use dialoguer::{Input, Password};
use git2::{Repository, Signature, Time};
use indicatif::{ProgressBar, ProgressStyle};
use std::fs;
use std::path::Path;
use tempfile::TempDir;

/// Create GitHub repositories with backdated commits to show early years in your profile
#[derive(Parser)]
#[command(name = "git-timetraveler")]
#[command(about = "Travel back in time on your GitHub profile")]
#[command(version = "0.1.0")]
struct Args {
    /// Year to travel back to (e.g., 1990)
    #[arg(short, long, default_value = "1990")]
    year: u32,

    /// GitHub username
    #[arg(short, long)]
    username: Option<String>,

    /// GitHub personal access token
    #[arg(short, long)]
    token: Option<String>,

    /// Month (1-12)
    #[arg(short, long, default_value = "1")]
    month: u32,

    /// Day (1-31)
    #[arg(short, long, default_value = "1")]
    day: u32,

    /// Hour (0-23)
    #[arg(long, default_value = "18")]
    hour: u32,

    /// Skip confirmation prompts
    #[arg(short = 'y', long)]
    yes: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();

    println!("{}", "üöÄ Git Time Traveler".bright_blue().bold());
    println!("{}", "Travel back in time on your GitHub profile!".cyan());
    println!();

    // Validate year
    if args.year < 1970 || args.year > 2030 {
        anyhow::bail!("Year must be between 1970 and 2030");
    }

    // Get username and token (from args or prompt) - clone to avoid partial move
    let username = get_username(args.username.clone())?;
    let token = get_token(args.token.clone())?;

    // Validate inputs
    if username.trim().is_empty() {
        anyhow::bail!("Username cannot be empty");
    }
    if token.trim().is_empty() {
        anyhow::bail!("Access token cannot be empty");
    }

    // Show summary
    println!("üìÖ Target date: {}-{:02}-{:02} at {:02}:00:00", 
             args.year, args.month, args.day, args.hour);
    println!("üë§ GitHub user: {}", username.bright_green());
    println!("üì¶ Repository: {}", format!("{}", args.year).bright_yellow());
    println!();

    // Confirmation
    if !args.yes {
        let confirm = dialoguer::Confirm::new()
            .with_prompt("Do you want to proceed?")
            .default(true)
            .interact()?;
        
        if !confirm {
            println!("{}", "Operation cancelled.".yellow());
            return Ok(());
        }
    }

    // Create progress bar
    let pb = ProgressBar::new(6);
    pb.set_style(
        ProgressStyle::default_bar()
            .template("{spinner:.green} [{elapsed_precise}] {bar:40.cyan/blue} {pos:>2}/{len:2} {msg}")
            .unwrap()
            .progress_chars("‚ñà‚ñâ‚ñä‚ñã‚ñå‚ñç‚ñé‚ñè  "),
    );

    // Execute the time travel
    time_travel(&args, &username, &token, &pb).await?;

    pb.finish_with_message("‚úÖ Time travel complete!");
    println!();
    println!("{}", "üéâ Success!".bright_green().bold());
    println!("Check your profile: {}", 
             format!("https://github.com/{}", username).bright_blue().underline());

    Ok(())
}

fn get_username(username: Option<String>) -> Result<String> {
    match username {
        Some(u) => Ok(u),
        None => {
            let username: String = Input::new()
                .with_prompt("GitHub Username")
                .interact_text()?;
            Ok(username)
        }
    }
}

fn get_token(token: Option<String>) -> Result<String> {
    match token {
        Some(t) => Ok(t),
        None => {
            let token: String = Password::new()
                .with_prompt("GitHub Personal Access Token")
                .interact()?;
            Ok(token)
        }
    }
}

async fn time_travel(args: &Args, username: &str, token: &str, pb: &ProgressBar) -> Result<()> {
    pb.set_message("Creating temporary directory...");
    pb.inc(1);

    // Create temporary directory
    let temp_dir = TempDir::new().context("Failed to create temporary directory")?;
    let repo_path = temp_dir.path().join(&args.year.to_string());
    fs::create_dir_all(&repo_path).context("Failed to create repository directory")?;

    pb.set_message("Initializing Git repository...");
    pb.inc(1);

    // Initialize Git repository
    let repo = Repository::init(&repo_path).context("Failed to initialize Git repository")?;

    pb.set_message("Creating README file...");
    pb.inc(1);

    // Create README.md
    let readme_content = format!(
        "**{}** - Generated by [Git Time Traveler](https://github.com/yourusername/git-timetraveler)\n\nüöÄ This repository was created to show activity in the year {} on my GitHub profile.\n",
        args.year, args.year
    );
    let readme_path = repo_path.join("README.md");
    fs::write(&readme_path, readme_content).context("Failed to write README.md")?;

    pb.set_message("Staging files...");
    pb.inc(1);

    // Stage files
    let mut index = repo.index().context("Failed to get repository index")?;
    index.add_path(Path::new("README.md")).context("Failed to add README.md to index")?;
    index.write().context("Failed to write index")?;

    pb.set_message("Creating backdated commit...");
    pb.inc(1);

    // Create commit with backdated timestamp
    let tree_id = index.write_tree().context("Failed to write tree")?;
    let tree = repo.find_tree(tree_id).context("Failed to find tree")?;

    // Create the backdated timestamp
    let commit_time = create_commit_time(args.year, args.month, args.day, args.hour)?;
    let signature = Signature::new("Git Time Traveler", "timetraveler@example.com", &commit_time)
        .context("Failed to create signature")?;

    let commit_message = format!("{}", args.year);
    repo.commit(
        Some("HEAD"),
        &signature,
        &signature,
        &commit_message,
        &tree,
        &[],
    ).context("Failed to create commit")?;

    pb.set_message("Pushing to GitHub...");
    pb.inc(1);

    // Push to GitHub
    push_to_github(&repo, username, token, &args.year.to_string()).await?;

    Ok(())
}

fn create_commit_time(year: u32, month: u32, day: u32, hour: u32) -> Result<Time> {
    // Create a DateTime for the specified date
    let datetime_str = format!("{}-{:02}-{:02}T{:02}:00:00Z", year, month, day, hour);
    let datetime = DateTime::parse_from_rfc3339(&datetime_str)
        .context("Failed to parse datetime")?;
    
    let timestamp = datetime.timestamp();
    
    // git2::Time::new takes (seconds, offset_minutes)
    Ok(Time::new(timestamp, 0)) // UTC offset = 0 minutes
}

async fn push_to_github(repo: &Repository, username: &str, token: &str, repo_name: &str) -> Result<()> {
    let remote_url = format!("https://{}@github.com/{}/{}.git", token, username, repo_name);
    
    // Add remote
    let mut remote = repo.remote("origin", &remote_url)
        .context("Failed to add remote origin")?;

    // Create credentials callback
    let mut callbacks = git2::RemoteCallbacks::new();
    callbacks.credentials(|_url, username_from_url, _allowed_types| {
        git2::Cred::userpass_plaintext(username_from_url.unwrap_or("git"), token)
    });

    // Push options
    let mut push_options = git2::PushOptions::new();
    push_options.remote_callbacks(callbacks);

    // Get the current branch reference
    let head = repo.head().context("Failed to get HEAD reference")?;
    let refspec = format!("{}:refs/heads/main", head.name().unwrap_or("HEAD"));

    // Push to remote
    remote.push(&[&refspec], Some(&mut push_options))
        .context("Failed to push to remote repository")?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_commit_time() {
        let time = create_commit_time(1990, 1, 1, 18).unwrap();
        assert_eq!(time.seconds(), 631134000); // Unix timestamp for 1990-01-01 18:00:00 UTC
    }

    #[test]
    fn test_year_validation() {
        // This would be tested in integration tests
        assert!(1990 >= 1970 && 1990 <= 2030);
    }
}
