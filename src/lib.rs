use anyhow::{Context, Result};
use chrono::DateTime;
use git2::{Repository, Signature, Time};
use std::fs;
use std::path::Path;
use tempfile::TempDir;

/// Configuration for creating a time-traveled repository
#[derive(Debug, Clone)]
pub struct TimeTravelConfig {
    pub year: u32,
    pub month: u32,
    pub day: u32,
    pub hour: u32,
    pub username: String,
    pub token: String,
}

impl TimeTravelConfig {
    /// Create a new configuration with validation
    pub fn new(
        year: u32,
        month: u32,
        day: u32,
        hour: u32,
        username: String,
        token: String,
    ) -> Result<Self> {
        // Validate inputs
        if year < 1970 || year > 2030 {
            anyhow::bail!("Year must be between 1970 and 2030");
        }
        if month < 1 || month > 12 {
            anyhow::bail!("Month must be between 1 and 12");
        }
        if day < 1 || day > 31 {
            anyhow::bail!("Day must be between 1 and 31");
        }
        if hour > 23 {
            anyhow::bail!("Hour must be between 0 and 23");
        }
        if username.trim().is_empty() {
            anyhow::bail!("Username cannot be empty");
        }
        if token.trim().is_empty() {
            anyhow::bail!("Access token cannot be empty");
        }

        Ok(Self {
            year,
            month,
            day,
            hour,
            username,
            token,
        })
    }

    /// Get the repository name (same as year)
    pub fn repo_name(&self) -> String {
        self.year.to_string()
    }

    /// Get the commit timestamp as a Git Time
    pub fn commit_time(&self) -> Result<Time> {
        let datetime_str = format!("{}-{:02}-{:02}T{:02}:00:00Z", 
                                  self.year, self.month, self.day, self.hour);
        let datetime = DateTime::parse_from_rfc3339(&datetime_str)
            .context("Failed to parse datetime")?;
        
        let timestamp = datetime.timestamp();
        Ok(Time::new(timestamp, 0)) // UTC offset = 0 minutes
    }

    /// Get the formatted date string for display
    pub fn formatted_date(&self) -> String {
        format!("{}-{:02}-{:02} at {:02}:00:00", 
                self.year, self.month, self.day, self.hour)
    }
}

/// Progress callback trait for reporting progress
pub trait ProgressCallback {
    fn set_message(&self, message: &str);
    fn increment(&self);
    fn finish(&self, message: &str);
}

/// Create a time-traveled repository and push it to GitHub
pub async fn create_time_traveled_repo(
    config: &TimeTravelConfig,
    progress: Option<&dyn ProgressCallback>,
) -> Result<()> {
    let report_progress = |msg: &str| {
        if let Some(p) = &progress {
            p.set_message(msg);
            p.increment();
        }
    };

    report_progress("Creating temporary directory...");

    // Create temporary directory
    let temp_dir = TempDir::new().context("Failed to create temporary directory")?;
    let repo_path = temp_dir.path().join(&config.repo_name());
    fs::create_dir_all(&repo_path).context("Failed to create repository directory")?;

    report_progress("Initializing Git repository...");

    // Initialize Git repository
    let repo = Repository::init(&repo_path).context("Failed to initialize Git repository")?;

    report_progress("Creating README file...");

    // Create README.md
    let readme_content = format!(
        "**{}** - Generated by [Git Time Traveler](https://github.com/yourusername/git-timetraveler)\n\nðŸš€ This repository was created to show activity in the year {} on my GitHub profile.\n\n## About\n\nThis commit was backdated to {} using Git Time Traveler, a modern Rust CLI tool for creating historical GitHub contributions.\n",
        config.year, config.year, config.formatted_date()
    );
    let readme_path = repo_path.join("README.md");
    fs::write(&readme_path, readme_content).context("Failed to write README.md")?;

    report_progress("Staging files...");

    // Stage files
    let mut index = repo.index().context("Failed to get repository index")?;
    index.add_path(Path::new("README.md")).context("Failed to add README.md to index")?;
    index.write().context("Failed to write index")?;

    report_progress("Creating backdated commit...");

    // Create commit with backdated timestamp
    let tree_id = index.write_tree().context("Failed to write tree")?;
    let tree = repo.find_tree(tree_id).context("Failed to find tree")?;

    let commit_time = config.commit_time()?;
    let signature = Signature::new("Git Time Traveler", "timetraveler@example.com", &commit_time)
        .context("Failed to create signature")?;

    let commit_message = format!("{}", config.year);
    repo.commit(
        Some("HEAD"),
        &signature,
        &signature,
        &commit_message,
        &tree,
        &[],
    ).context("Failed to create commit")?;

    report_progress("Pushing to GitHub...");

    // Push to GitHub
    push_to_github(&repo, &config.username, &config.token, &config.repo_name()).await?;

    if let Some(p) = progress {
        p.finish("âœ… Time travel complete!");
    }

    Ok(())
}

async fn push_to_github(repo: &Repository, username: &str, token: &str, repo_name: &str) -> Result<()> {
    let remote_url = format!("https://{}@github.com/{}/{}.git", token, username, repo_name);
    
    // Add remote
    let mut remote = repo.remote("origin", &remote_url)
        .context("Failed to add remote origin")?;

    // Create credentials callback
    let mut callbacks = git2::RemoteCallbacks::new();
    callbacks.credentials(|_url, username_from_url, _allowed_types| {
        git2::Cred::userpass_plaintext(username_from_url.unwrap_or("git"), token)
    });

    // Push options
    let mut push_options = git2::PushOptions::new();
    push_options.remote_callbacks(callbacks);

    // Get the current branch reference
    let head = repo.head().context("Failed to get HEAD reference")?;
    let refspec = format!("{}:refs/heads/main", head.name().unwrap_or("HEAD"));

    // Push to remote
    remote.push(&[&refspec], Some(&mut push_options))
        .context("Failed to push to remote repository")?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_time_travel_config_validation() {
        // Valid config
        let config = TimeTravelConfig::new(
            1990, 1, 1, 18,
            "testuser".to_string(),
            "token123".to_string()
        );
        assert!(config.is_ok());

        // Invalid year
        let config = TimeTravelConfig::new(
            1969, 1, 1, 18,
            "testuser".to_string(),
            "token123".to_string()
        );
        assert!(config.is_err());

        // Invalid month
        let config = TimeTravelConfig::new(
            1990, 13, 1, 18,
            "testuser".to_string(),
            "token123".to_string()
        );
        assert!(config.is_err());

        // Empty username
        let config = TimeTravelConfig::new(
            1990, 1, 1, 18,
            "".to_string(),
            "token123".to_string()
        );
        assert!(config.is_err());
    }

    #[test]
    fn test_commit_time_creation() {
        let config = TimeTravelConfig::new(
            1990, 1, 1, 18,
            "testuser".to_string(),
            "token123".to_string()
        ).unwrap();

        let time = config.commit_time().unwrap();
        assert_eq!(time.seconds(), 631216800); // Unix timestamp for 1990-01-01 18:00:00 UTC
    }

    #[test]
    fn test_formatted_date() {
        let config = TimeTravelConfig::new(
            1990, 1, 1, 18,
            "testuser".to_string(),
            "token123".to_string()
        ).unwrap();

        assert_eq!(config.formatted_date(), "1990-01-01 at 18:00:00");
    }

    #[test]
    fn test_repo_name() {
        let config = TimeTravelConfig::new(
            1990, 1, 1, 18,
            "testuser".to_string(),
            "token123".to_string()
        ).unwrap();

        assert_eq!(config.repo_name(), "1990");
    }
} 