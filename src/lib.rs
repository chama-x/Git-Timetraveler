use anyhow::{Context, Result};
use chrono::DateTime;
use std::fs;
use std::path::Path;
use std::process::Command;
use tempfile::TempDir;

/// Configuration for creating a time-traveled repository
#[derive(Debug, Clone)]
pub struct TimeTravelConfig {
    pub year: u32,
    pub month: u32,
    pub day: u32,
    pub hour: u32,
    pub username: String,
    pub token: String,
}

impl TimeTravelConfig {
    /// Create a new configuration with validation
    pub fn new(
        year: u32,
        month: u32,
        day: u32,
        hour: u32,
        username: String,
        token: String,
    ) -> Result<Self> {
        // Validate year (reasonable range)
        if year < 1970 || year > 2030 {
            anyhow::bail!("Year must be between 1970 and 2030");
        }
        
        // Validate month
        if month < 1 || month > 12 {
            anyhow::bail!("Month must be between 1 and 12");
        }
        
        // Validate day
        if day < 1 || day > 31 {
            anyhow::bail!("Day must be between 1 and 31");
        }
        
        // Validate hour
        if hour > 23 {
            anyhow::bail!("Hour must be between 0 and 23");
        }
        
        // Validate username
        if username.trim().is_empty() {
            anyhow::bail!("Username cannot be empty");
        }
        
        // Validate token
        if token.trim().is_empty() {
            anyhow::bail!("Token cannot be empty");
        }
        
        Ok(Self {
            year,
            month,
            day,
            hour,
            username,
            token,
        })
    }

    /// Get the repository name (same as year)
    pub fn repo_name(&self) -> String {
        self.year.to_string()
    }

    /// Get the commit timestamp as an ISO 8601 string
    pub fn commit_timestamp(&self) -> Result<String> {
        let datetime_str = format!("{}-{:02}-{:02}T{:02}:00:00", 
                                  self.year, self.month, self.day, self.hour);
        let datetime = DateTime::parse_from_rfc3339(&format!("{}Z", datetime_str))
            .context("Failed to parse datetime")?;
        
        Ok(datetime.format("%Y-%m-%dT%H:%M:%S").to_string())
    }

    /// Get the formatted date string for display
    pub fn formatted_date(&self) -> String {
        format!("{}-{:02}-{:02} at {:02}:00:00", 
                self.year, self.month, self.day, self.hour)
    }
}

/// Progress callback trait for reporting progress
pub trait ProgressCallback {
    fn set_message(&self, message: &str);
    fn increment(&self);
    fn finish(&self, message: &str);
}

/// Create a time-traveled repository and push it to GitHub
pub async fn create_time_traveled_repo(
    config: &TimeTravelConfig,
    progress: Option<&dyn ProgressCallback>,
) -> Result<()> {
    let report_progress = |msg: &str| {
        if let Some(p) = &progress {
            p.set_message(msg);
            p.increment();
        }
    };

    report_progress("Creating temporary directory...");
    let temp_dir = TempDir::new().context("Failed to create temporary directory")?;
    let repo_path = temp_dir.path().join(&config.repo_name());
    fs::create_dir_all(&repo_path).context("Failed to create repository directory")?;

    report_progress("Initializing Git repository...");
    run_git_command(&repo_path, &["init"])?;

    report_progress("Creating README file...");
    let readme_content = format!(
        "**{}** - Generated by [Git Time Traveler](https://github.com/chama-x/Git-Timetraveler)\n\nðŸš€ This repository was created to show activity in the year {} on my GitHub profile.\n\n## About\n\nThis commit was backdated to {} using Git Time Traveler, a modern Rust CLI tool for creating historical GitHub contributions.\n",
        config.year, config.year, config.formatted_date()
    );
    let readme_path = repo_path.join("README.md");
    fs::write(&readme_path, readme_content).context("Failed to write README.md")?;

    report_progress("Staging files...");
    run_git_command(&repo_path, &["add", "."])?;

    report_progress("Creating backdated commit...");
    let timestamp = config.commit_timestamp()?;
    let commit_message = format!("{}", config.year);
    
    run_git_command_with_env(
        &repo_path,
        &["commit", "-m", &commit_message],
        &[
            ("GIT_AUTHOR_DATE", &timestamp),
            ("GIT_COMMITTER_DATE", &timestamp),
            ("GIT_AUTHOR_NAME", "Git Time Traveler"),
            ("GIT_AUTHOR_EMAIL", "timetraveler@example.com"),
            ("GIT_COMMITTER_NAME", "Git Time Traveler"),
            ("GIT_COMMITTER_EMAIL", "timetraveler@example.com"),
        ],
    )?;

    report_progress("Pushing to GitHub...");
    push_to_github(&repo_path, &config.username, &config.token, &config.repo_name()).await?;

    if let Some(p) = progress {
        p.finish("âœ… Time travel complete!");
    }

    Ok(())
}

/// Run a git command in the specified directory
fn run_git_command(repo_path: &Path, args: &[&str]) -> Result<()> {
    let output = Command::new("git")
        .current_dir(repo_path)
        .args(args)
        .output()
        .context("Failed to execute git command")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("Git command failed: {}", stderr);
    }

    Ok(())
}

/// Run a git command with environment variables
fn run_git_command_with_env(
    repo_path: &Path,
    args: &[&str],
    env_vars: &[(&str, &str)],
) -> Result<()> {
    let mut cmd = Command::new("git");
    cmd.current_dir(repo_path).args(args);
    
    for (key, value) in env_vars {
        cmd.env(key, value);
    }

    let output = cmd.output().context("Failed to execute git command")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("Git command failed: {}", stderr);
    }

    Ok(())
}

/// Push the repository to GitHub
async fn push_to_github(
    repo_path: &Path,
    username: &str,
    token: &str,
    repo_name: &str,
) -> Result<()> {
    let remote_url = format!("https://{}@github.com/{}/{}.git", token, username, repo_name);
    
    // Add remote origin
    run_git_command(repo_path, &["remote", "add", "origin", &remote_url])?;
    
    // Set main branch
    run_git_command(repo_path, &["branch", "-M", "main"])?;
    
    // Push to origin
    run_git_command(repo_path, &["push", "-u", "origin", "main", "--force"])?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_time_travel_config_validation() {
        // Valid config
        let config = TimeTravelConfig::new(
            1990, 1, 1, 18,
            "testuser".to_string(),
            "token123".to_string()
        );
        assert!(config.is_ok());

        // Invalid year
        let config = TimeTravelConfig::new(
            1969, 1, 1, 18,
            "testuser".to_string(),
            "token123".to_string()
        );
        assert!(config.is_err());

        // Invalid month
        let config = TimeTravelConfig::new(
            1990, 13, 1, 18,
            "testuser".to_string(),
            "token123".to_string()
        );
        assert!(config.is_err());

        // Empty username
        let config = TimeTravelConfig::new(
            1990, 1, 1, 18,
            "".to_string(),
            "token123".to_string()
        );
        assert!(config.is_err());
    }

    #[test]
    fn test_commit_timestamp() {
        let config = TimeTravelConfig::new(
            1990, 1, 1, 18,
            "testuser".to_string(),
            "token123".to_string()
        ).unwrap();

        let timestamp = config.commit_timestamp().unwrap();
        assert_eq!(timestamp, "1990-01-01T18:00:00");
    }

    #[test]
    fn test_formatted_date() {
        let config = TimeTravelConfig::new(
            1990, 1, 1, 18,
            "testuser".to_string(),
            "token123".to_string()
        ).unwrap();

        assert_eq!(config.formatted_date(), "1990-01-01 at 18:00:00");
    }

    #[test]
    fn test_repo_name() {
        let config = TimeTravelConfig::new(
            1990, 1, 1, 18,
            "testuser".to_string(),
            "token123".to_string()
        ).unwrap();

        assert_eq!(config.repo_name(), "1990");
    }
} 